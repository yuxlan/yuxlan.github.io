<!-- 共用的布局文件 -->

<!DOCTYPE html>
<html>
  <!-- THE HEAD OF HTML FILES -->

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-COMPATIBLE" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="description" content="about personal">
  <meta name="keyword" content="hexo ejs blog personalPage">

  <link rel="shortcut icon" href="/images/favicon.png">

  <title>YuXLan</title>

  <!-- NORMALIZE CSS -->
  <link rel="stylesheet" href="/css/normalize.css">

  <!-- BOOTSTRAP CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- FONTAWESOME -->
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.css">

  <!-- PLUGIN -->
  <link rel="stylesheet" href="/css/magnific-popup.css">
  <link rel="stylesheet" href="/css/slider-pro.css">
  <link rel="stylesheet" href="/css/owl.carousel.css">
  <link rel="stylesheet" href="/css/owl.theme.css">
  <link rel="stylesheet" href="/css/owl.transitions.css">
  <link rel="stylesheet" href="/css/animate.css">

  <!-- MAINSTYLE -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- BASIC JS -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/modernizr.min.js"></script>
    <script src="/js/jquery.easing.js"></script>
    <script src="/js/jquery.scrollUp.min.js"></script>
    <script src="/js/smooth-scroll.min.js"></script>
    <script src="/js/jquery.magnific-popup.min.js"></script>
    <script src="/js/jquery.sliderPro.min.js"></script>
    <script src="/js/owl.carousel.min.js"></script>
    <script src="/js/jquery.easypiechart.js"></script>
    <script src="/js/jquery.countTo.js"></script>
    <script src="/js/isotope.pkgd.min.js"></script>
    <script src="/js/jquery.stellar.min.js"></script>
    <script src="/js/jquery.waypoints.min.js"></script>
    <script src="/js/wow.min.js"></script>
    <script src="/js/jquery.nav.js"></script>
    <script src="/js/custom.js"></script>

  <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/zenburn.min.css">

</head>
  <body>
      <!-- THE HEADER + NAV -->


<header>
    <!-- Nav Menu start-->
    <nav class="navbar clean-main-menu" role="navigation">
        <div class="container">

            <!-- Nav Toggle -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <!-- Logo -->
                <a class="navbar-brand logo" href="index.html" id="logo">
                    YuXLan
                </a>

            </div>
            <!-- Nav Toggle End -->

            <!-- Nav-collapse start-->
            <div id="nav-menu" class="navbar-collapse collapse" role="navigation">
                <ul class="nav navbar-nav clean-menu-wrapper">
                    
                    <li>
                        <a href="/" class="menu-item-link">
                            首页
                        </a>
                    </li>
                    
                    <li>
                        <a href="/about.html" class="menu-item-link">
                            关于
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://github.com/yuxlan" class="menu-item-link">
                            作品集
                        </a>
                    </li>
                    
                </ul>
            </div>
            <!-- Nav-collapse End-->

        </div>
    </nav>
    <!-- Nav Menu End-->
</header>
      <!-- 文章详情页对应的布局文件 -->


<!-- SLIDER SECTION -->

<div>
    <img src="/images/4.jpg"/>
</div>

<section id="offer" class="clean-section-wrapper-1 clean-offer-section"
         style="background: url('/images/top.png') bottom center no-repeat;
                 background-size: 60px;">


    <div class="container">
        <div class="row">

            <!-- Blogs -->
            <div class="col-md-12 col-sm-12 col-xs-12 clean-section-header-1 wow fadeInDown">
                <h1>
                    <span class="clean-color-contras">
                        十大经典排序算法的 JS 版
                    </span>
                </h1>
                <div class="clean-line"></div>
                <div class="post-meta text-center">
                    <span class="post-time">2017-07-19</span>
                </div>
                <p class="col-md-8 col-sm-10 col-xs-12 col-md-offset-2 col-sm-offset-1">
                    <hr>
<p><a href="https://www.zybuluo.com/yuxlan/note/821853" target="_blank" rel="external">作业部落地址链接</a></p>
<hr>
<p><strong>排序算法总结</strong><br><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2924073986,1343460850&amp;fm=11&amp;gp=0.jpg" alt="此处输入图片的描述"></p>
<hr>
<p><strong>1.冒泡排序（Bubble Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></p>
<p><2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></p>
<p><3>.针对所有的元素重复以上的步骤，除了最后一个；</3></p>
<p><4>.重复步骤1~3，直到排序完成。</4></p>
</blockquote>
<p>JavaScript代码实现：</p>
<pre><code>function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre><p>改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>改进后算法如下:</p>
<pre><code>function bubbleSort2(arr) {
    console.time(&apos;改进后冒泡排序耗时&apos;);
    var i = arr.length-1;  //初始时,最后位置保持不变
    while ( i&gt; 0) {
        var pos= 0; //每趟开始时,无记录交换
        for (var j= 0; j&lt; i; j++)
            if (arr[j]&gt; arr[j+1]) {
                pos= j; //记录交换的位置
                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            }
        i= pos; //为下一趟排序作准备
     }
     console.timeEnd(&apos;改进后冒泡排序耗时&apos;);
     return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre><p>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。<br>改进后的算法实现为:</p>
<pre><code>function bubbleSort3(arr3) {
    var low = 0;
    var high= arr.length-1; //设置变量的初始值
    var tmp,j;
    console.time(&apos;2.改进后冒泡排序耗时&apos;);
    while (low &lt; high) {
        for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者
            if (arr[j]&gt; arr[j+1]) {
                tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;
            }
        --high;                 //修改high值, 前移一位
        for (j=high; j&gt;low; --j) //反向冒泡,找到最小者
            if (arr[j]&lt;arr[j-1]) {
                tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp;
            }
        ++low;                  //修改low值,后移一位
    }
    console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;);
    return arr3;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre><hr>
<p><strong>2.选择排序（Selection Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.初始状态：无序区为R[1..n]，有序区为空；</1></p>
<p><2>.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录<br>R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></p>
<p><3>.n-1趟结束，数组有序化了。</3></p>
</blockquote>
<p>Javascript代码实现:</p>
<pre><code>function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    console.time(&apos;选择排序耗时&apos;);
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    console.timeEnd(&apos;选择排序耗时&apos;);
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre><hr>
<p><strong>3.插入排序（Insertion Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.从第一个元素开始，该元素可以认为已经被排序；</1></p>
<p><2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></p>
<p><3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></p>
<p><4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></p>
<p><5>.将新元素插入到该位置后； </5></p>
<p><6>.重复步骤2~5。</6></p>
</blockquote>
<p>Javascript代码实现:</p>
<pre><code>function insertionSort(array) {
    if (Object.prototype.toString.call(array).slice(8, -1) === &apos;Array&apos;) {
        console.time(&apos;插入排序耗时：&apos;);
        for (var i = 1; i &lt; array.length; i++) {
            var key = array[i];
            var j = i - 1;
            while (j &gt;= 0 &amp;&amp; array[j] &gt; key) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
        console.timeEnd(&apos;插入排序耗时：&apos;);
        return array;
    } else {
        return &apos;array is not an Array!&apos;;
    }
}
</code></pre><p>改进插入排序： 查找插入位置时使用二分查找的方式</p>
<pre><code>function binaryInsertionSort(array) {
    if (Object.prototype.toString.call(array).slice(8, -1) === &apos;Array&apos;) {
        console.time(&apos;二分插入排序耗时：&apos;);
        for (var i = 1; i &lt; array.length; i++) {
            var key = array[i], left = 0, right = i - 1;
            while (left &lt;= right) {
                var middle = parseInt((left + right) / 2);
                if (key &lt; array[middle]) {
                    right = middle - 1;
                } else {
                    left = middle + 1;
                }
            }
            for (var j = i - 1; j &gt;= left; j--) {
                array[j + 1] = array[j];
            }
            array[left] = key;
        }
        console.timeEnd(&apos;二分插入排序耗时：&apos;);
        return array;
    } else {
        return &apos;array is not an Array!&apos;;
    }
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre><hr>
<p><strong>4.希尔排序（Shell Sort）</strong></p>
<p>具体算法描述：</p>
<blockquote>
<p><1>. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></p>
<p><2>.按增量序列个数k，对序列进行k 趟排序；</2></p>
<p><3>.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></p>
</blockquote>
<p>Javascript代码实现：</p>
<pre><code>function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    console.time(&apos;希尔排序耗时:&apos;);
    while(gap &lt; len/5) {          //动态定义间隔序列
        gap =gap*5+1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap/5)) {
        for (var i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    console.timeEnd(&apos;希尔排序耗时:&apos;);
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre><hr>
<p><strong>5.归并排序（Merge Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.把长度为n的输入序列分成两个长度为n/2的子序列；</1></p>
<p><2>.对这两个子序列分别采用归并排序；</2></p>
<p><3>.将两个排序好的子序列合并成一个最终的排序序列。</3></p>
</blockquote>
<p>Javscript代码实现:</p>
<pre><code>function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
function merge(left, right)
{
    var result = [];
    console.time(&apos;归并排序耗时&apos;);
    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
    while (left.length)
        result.push(left.shift());
    while (right.length)
        result.push(right.shift());
    console.timeEnd(&apos;归并排序耗时&apos;);
    return result;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(mergeSort(arr));
</code></pre><hr>
<p><strong>6.快速排序（Quick Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.从数列中挑出一个元素，称为 “基准”（pivot）；</1></p>
<p><2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></p>
<p><3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></p>
</blockquote>
<p>Javascript代码实现：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1500479065&amp;di=89b0953f0aa0ce4e7768817164636792&amp;src=http://img.mp.sohu.com/upload/20170715/f7b4a59c10b349c7b923fb9634463db0_th.png" alt="此处输入图片的描述"></p>
<hr>
<p><strong>7.堆排序（Heap Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></p>
<p><2>.将堆顶元素R<a href="https://www.zybuluo.com/yuxlan/note/821853" target="_blank" rel="external">1</a>与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></p>
<p><3>.由于交换后新的堆顶R<a href="https://www.zybuluo.com/yuxlan/note/821853" target="_blank" rel="external">1</a>可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R<a href="https://www.zybuluo.com/yuxlan/note/821853" target="_blank" rel="external">1</a>与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></p>
</blockquote>
<p>Javascript代码实现：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1500479146&amp;di=add78eed3c30364ae43deb2e566a3988&amp;src=http://i.dimg.cc/d2/39/f6/95/ec/d7/5d/41/3e/41/a6/ed/cf/26/90/dd.jpg" alt="此处输入图片的描述"></p>
<hr>
<p><strong>8.计数排序（Counting Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>. 找出待排序的数组中最大和最小的元素； <2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； <3>.<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； <4>.<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></3></2></1></p>
</blockquote>
<p>Javascript代码实现：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1500479221&amp;di=1fc2e464f669cdde3e7848a358bf687f&amp;src=http://img.mp.sohu.com/upload/20170715/c039a3d5b7f2493298125bb89948351a_th.png" alt="此处输入图片的描述"></p>
<hr>
<p><strong>9.桶排序（Bucket Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.设置一个定量的数组当作空桶；</1></p>
<p><2>.遍历输入数据，并且把数据一个一个放到对应的桶里去；</2></p>
<p><3>.对每个不是空的桶进行排序；</3></p>
<p><4>.从不是空的桶里把排好序的数据拼接起来。</4></p>
</blockquote>
<p>Javascript代码实现:<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1500479279&amp;di=9d0001544bff79c5a640317339e79953&amp;src=http://img.mp.sohu.com/upload/20170715/497db94733a14909945af8f243af191f_th.png" alt="此处输入图片的描述"></p>
<hr>
<p><strong>10.基数排序（Radix Sort）</strong></p>
<p>具体算法描述如下：</p>
<blockquote>
<p><1>.取得数组中的最大数，并取得位数； <2>.arr为原始数组，从最低位开始取每个位组成radix数组；</2></1></p>
<p><3>.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</3></p>
</blockquote>
<p>Javascript代码实现：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1500479326&amp;di=023dc72892d221d82bf001023263d1a1&amp;src=http://img.mp.sohu.com/upload/20170715/6535b77382c3471c93606f0d8e161dad_th.png" alt="此处输入图片的描述"></p>
<hr>

                    <br/><br/>
                </p>

                <!-- Next blog -->
                <div class="pager-position">
                    <ul class="pager">
                        
                        <li class="previous">
                            <a href="/2017/08/19/方法链/" data-toggle="tooltip" data-placement="top"
                               title="方法链">&larr; 上一篇</a>
                        </li>
                        
                        
                        <li class="next">
                            <a href="/2017/06/19/SVN版本控制工具/" data-toggle="tooltip" data-placement="top"
                               title="SVN版本控制工具">下一篇 &rarr;</a>
                        </li>
                        
                    </ul>
                </div>
                <!-- END -->

            </div>
            <!-- Blogs End -->



        </div>
    </div>
</section>
      <!-- FOOTER SECTION -->

<footer class="background-one"
        style="background: url('/images/bottom.png') top center no-repeat;
        background-size: 60px;">
    <div class="container">
        <div class="row">
            <div class="clean-footer-content">

                <div class="clean-footer-logo wow bounceIn" data-wow-offset="0">
                    <a href="index.html" id="logo-footer">
                        YuXLan
                    </a>
                </div>

                <p class="clean-copyright-info">
                    Copyright &copy; <a href="http://www.miitbeian.gov.cn/" target="_blank">浙ICP备17018917号</a> - writted by YuXLan
                </p>

                <ul class="clean-footer-social-info">
                    <li>
                        <a href="https://github.com/yuxlan" target="_blank"><i class="fa fa-github"></i></a>
                    </li>
                    <li>
                        <a href="https://codepen.io/YuXLan/" target="_blank"><i class="fa fa-codepen"></i></a>
                    </li>
                    <li>
                        <a href="http://www.linkedin.com/in/%E5%B0%8F%E5%85%B0-%E4%BD%99-3467b513b/" target="_blank"><i class="fa fa-linkedin"></i></a>
                    </li>
                    <li>
                        <a href="http://weibo.com/5287171180/profile?topnav=1&wvr=6&is_all=1" target="_blank"><i class="fa fa-weibo"></i></a>
                    </li>
                </ul>

            </div>
        </div>
    </div>
</footer>
  </body>
</html>